<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from hdlconv
should_fail: 0
tags: hdlconv
incdirs: /home/travis/build/SymbiFlow/sv-tests/third_party/tests/hdlconvertor/tests/verilog
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/tests/hdlconvertor/tests/verilog/fifo_rx.v.html" target="file-frame">third_party/tests/hdlconvertor/tests/verilog/fifo_rx.v</a>
time_elapsed: 0.058s
ram usage: 10876 KB
</pre>
<pre class="log">

module fifo_rx (
	clock,
	reset,
	wr_en,
	rd_en,
	data_in,
	f_full,
	f_empty,
	open_slot_fct,
	overflow_credit_error,
	data_out,
	counter
);
	parameter integer DWIDTH = 9;
	parameter integer AWIDTH = 6;
	input clock;
	input reset;
	input wr_en;
	input rd_en;
	input [(DWIDTH - 1):0] data_in;
	output reg f_full;
	output reg f_empty;
	output reg open_slot_fct;
	output reg overflow_credit_error;
	output [(DWIDTH - 1):0] data_out;
	output reg [(AWIDTH - 1):0] counter;
	reg [(AWIDTH - 1):0] wr_ptr;
	reg [(AWIDTH - 1):0] rd_ptr;
	wire [(AWIDTH - 1):0] credit_counter;
	reg [1:0] state_data_write;
	reg [1:0] next_state_data_write;
	reg [1:0] state_data_read;
	reg [1:0] next_state_data_read;
	reg [1:0] state_open_slot;
	reg [1:0] next_state_open_slot;
	reg [10:0] counter_wait;
	always @(*) begin
		next_state_open_slot = state_open_slot;
		case (state_open_slot)
			2&#39;d0:
				if (((((((((rd_ptr == 6&#39;d7) || (rd_ptr == 6&#39;d15)) || (rd_ptr == 6&#39;d23)) || (rd_ptr == 6&#39;d31)) || (rd_ptr == 6&#39;d39)) || (rd_ptr == 6&#39;d47)) || (rd_ptr == 6&#39;d55)) || (rd_ptr == 6&#39;d63)))
					next_state_open_slot = 2&#39;d1;
				else
					next_state_open_slot = 2&#39;d0;
			2&#39;d1:
				if ((counter_wait != 11&#39;d300))
					next_state_open_slot = 2&#39;d1;
				else
					next_state_open_slot = 2&#39;d2;
			2&#39;d2:
				if (((((((((rd_ptr == 6&#39;d7) || (rd_ptr == 6&#39;d15)) || (rd_ptr == 6&#39;d23)) || (rd_ptr == 6&#39;d31)) || (rd_ptr == 6&#39;d39)) || (rd_ptr == 6&#39;d47)) || (rd_ptr == 6&#39;d55)) || (rd_ptr == 6&#39;d63)))
					next_state_open_slot = 2&#39;d2;
				else
					next_state_open_slot = 2&#39;d0;
			default: next_state_open_slot = 2&#39;d0;
		endcase
	end
	always @(*) begin
		next_state_data_write = state_data_write;
		case (state_data_write)
			2&#39;d0:
				if ((wr_en &amp;&amp; !f_full))
					next_state_data_write = 2&#39;d1;
				else
					next_state_data_write = 2&#39;d0;
			2&#39;d1:
				if (wr_en)
					next_state_data_write = 2&#39;d1;
				else
					next_state_data_write = 2&#39;d2;
			2&#39;d2: next_state_data_write = 2&#39;d0;
			default: next_state_data_write = 2&#39;d0;
		endcase
	end
	always @(*) begin
		next_state_data_read = state_data_read;
		case (state_data_read)
			2&#39;d0:
				if ((rd_en &amp;&amp; !f_empty))
					next_state_data_read = 2&#39;d1;
				else
					next_state_data_read = 2&#39;d0;
			2&#39;d1:
				if (rd_en)
					next_state_data_read = 2&#39;d1;
				else
					next_state_data_read = 2&#39;d2;
			2&#39;d2: next_state_data_read = 2&#39;d0;
			default: next_state_data_read = 2&#39;d0;
		endcase
	end
	always @(posedge clock or negedge reset)
		if (!reset) begin
			state_open_slot &lt;= 2&#39;d0;
			open_slot_fct &lt;= 1&#39;b0;
			counter_wait &lt;= 11&#39;d0;
		end
		else begin
			state_open_slot &lt;= next_state_open_slot;
			case (state_open_slot)
				2&#39;d0:
					if (((((((((rd_ptr == 6&#39;d7) || (rd_ptr == 6&#39;d15)) || (rd_ptr == 6&#39;d23)) || (rd_ptr == 6&#39;d31)) || (rd_ptr == 6&#39;d39)) || (rd_ptr == 6&#39;d47)) || (rd_ptr == 6&#39;d55)) || (rd_ptr == 6&#39;d63))) begin
						open_slot_fct &lt;= 1&#39;b1;
						counter_wait &lt;= (counter_wait + 11&#39;d1);
					end
					else
						open_slot_fct &lt;= 1&#39;b0;
				2&#39;d1: begin
					if ((counter_wait != 11&#39;d300))
						counter_wait &lt;= (counter_wait + 11&#39;d1);
					else
						counter_wait &lt;= counter_wait;
					open_slot_fct &lt;= 1&#39;b1;
				end
				2&#39;d2: begin
					counter_wait &lt;= 11&#39;d0;
					open_slot_fct &lt;= 1&#39;b0;
				end
				default: open_slot_fct &lt;= open_slot_fct;
			endcase
		end
	always @(posedge clock or negedge reset)
		if (!reset) begin
			state_data_write &lt;= 2&#39;d0;
			wr_ptr &lt;= {AWIDTH {1&#39;b0}};
		end
		else begin
			state_data_write &lt;= next_state_data_write;
			case (state_data_write)
				2&#39;d0: wr_ptr &lt;= wr_ptr;
				2&#39;d1: wr_ptr &lt;= wr_ptr;
				2&#39;d2: wr_ptr &lt;= (wr_ptr + 6&#39;d1);
				default: wr_ptr &lt;= wr_ptr;
			endcase
		end
	always @(posedge clock or negedge reset)
		if (!reset) begin
			f_full &lt;= 1&#39;b0;
			f_empty &lt;= 1&#39;b0;
			overflow_credit_error &lt;= 1&#39;b0;
			counter &lt;= {AWIDTH {1&#39;b0}};
		end
		else begin
			if ((state_data_write == 2&#39;d2))
				counter &lt;= (counter + 6&#39;d1);
			else if (((counter &gt; 6&#39;d0) &amp;&amp; (state_data_read == 2&#39;d2)))
				counter &lt;= (counter - 6&#39;d1);
			else
				counter &lt;= counter;
			if ((counter &gt; 6&#39;d56))
				overflow_credit_error &lt;= 1&#39;b1;
			else
				overflow_credit_error &lt;= 1&#39;b0;
			if ((counter == 6&#39;d56))
				f_full &lt;= 1&#39;b1;
			else
				f_full &lt;= 1&#39;b0;
			if ((counter == 6&#39;d0))
				f_empty &lt;= 1&#39;b1;
			else
				f_empty &lt;= 1&#39;b0;
		end
	always @(posedge clock or negedge reset)
		if (!reset) begin
			rd_ptr &lt;= {AWIDTH {1&#39;b0}};
			state_data_read &lt;= 2&#39;d0;
		end
		else begin
			state_data_read &lt;= next_state_data_read;
			case (state_data_read)
				2&#39;d0:
					if (rd_en)
						rd_ptr &lt;= (rd_ptr + 6&#39;d1);
					else
						rd_ptr &lt;= rd_ptr;
				2&#39;d1: rd_ptr &lt;= rd_ptr;
				2&#39;d2: rd_ptr &lt;= rd_ptr;
				default: rd_ptr &lt;= rd_ptr;
			endcase
		end
	mem_data mem_dta_fifo_rx(
		.clock(clock),
		.reset(reset),
		.data_in(data_in),
		.wr_ptr(wr_ptr),
		.rd_ptr(rd_ptr),
		.data_out(data_out)
	);
endmodule

</pre>
</body>