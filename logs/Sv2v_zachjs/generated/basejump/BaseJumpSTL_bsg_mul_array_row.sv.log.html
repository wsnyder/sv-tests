<head>
  <style>
    .log { font-family: "Courier New", Consolas, monospace; font-size: 80%; }
    .test-failed { background-color: #ffaaaa; }
    .test-passed { background-color: #aaffaa; }
  </style>
</head>
<body>
<h3><a href="https://github.com/zachjs/sv2v" target="_blank">zachjs-sv2v</a></h3>
<pre class="test-passed">
description: Tests imported from basejump
should_fail: 0
tags: basejump
incdirs: /home/travis/build/SymbiFlow/sv-tests/third_party/cores/basejump_stl/bsg_misc
top_module: 
type: parsing
mode: parsing
files: <a href="../../../../third_party/cores/basejump_stl/bsg_misc/bsg_mul_array_row.v.html" target="file-frame">third_party/cores/basejump_stl/bsg_misc/bsg_mul_array_row.v</a>
time_elapsed: 0.052s
ram usage: 10872 KB
</pre>
<pre class="log">

module bsg_mul_array_row (
	clk_i,
	rst_i,
	v_i,
	a_i,
	b_i,
	s_i,
	c_i,
	prod_accum_i,
	a_o,
	b_o,
	s_o,
	c_o,
	prod_accum_o
);
	parameter width_p = &#34;inv&#34;;
	parameter row_idx_p = &#34;inv&#34;;
	parameter pipeline_p = &#34;inv&#34;;
	input clk_i;
	input rst_i;
	input v_i;
	input [(width_p - 1):0] a_i;
	input [(width_p - 1):0] b_i;
	input [(width_p - 1):0] s_i;
	input c_i;
	input [row_idx_p:0] prod_accum_i;
	output reg [(width_p - 1):0] a_o;
	output reg [(width_p - 1):0] b_o;
	output reg [(width_p - 1):0] s_o;
	output reg c_o;
	output reg [(row_idx_p + 1):0] prod_accum_o;
	wire [(width_p - 1):0] pp;
	wire [(width_p - 1):0] ps;
	wire pc;
	bsg_and #(.width_p(width_p)) and0(
		.a_i(a_i),
		.b_i({width_p {b_i[(row_idx_p + 1)]}}),
		.o(pp)
	);
	bsg_adder_ripple_carry #(.width_p(width_p)) adder0(
		.a_i(pp),
		.b_i({c_i, s_i[(width_p - 1):1]}),
		.s_o(ps),
		.c_o(pc)
	);
	reg [(width_p - 1):0] a_r;
	reg [(width_p - 1):0] b_r;
	reg [(width_p - 1):0] s_r;
	reg c_r;
	reg [(row_idx_p + 1):0] prod_accum_r;
	reg [(width_p - 1):0] a_n;
	reg [(width_p - 1):0] b_n;
	reg [(width_p - 1):0] s_n;
	reg c_n;
	reg [(row_idx_p + 1):0] prod_accum_n;
	generate
		if (pipeline_p) begin
			always @(posedge clk_i)
				if (rst_i) begin
					a_r &lt;= 0;
					b_r &lt;= 0;
					s_r &lt;= 0;
					c_r &lt;= 0;
					prod_accum_r &lt;= 0;
				end
				else begin
					a_r &lt;= a_n;
					b_r &lt;= b_n;
					s_r &lt;= s_n;
					c_r &lt;= c_n;
					prod_accum_r &lt;= prod_accum_n;
				end
			always @(*) begin
				if (v_i) begin
					a_n = a_i;
					b_n = b_i;
					s_n = ps;
					c_n = pc;
					prod_accum_n = {ps[0], prod_accum_i};
				end
				else begin
					a_n = a_r;
					b_n = b_r;
					s_n = s_r;
					c_n = c_r;
					prod_accum_n = prod_accum_r;
				end
				a_o = a_r;
				b_o = b_r;
				s_o = s_r;
				c_o = c_r;
				prod_accum_o = prod_accum_r;
			end
		end
		else begin
			always @(*) begin
				a_o = a_i;
				b_o = b_i;
				s_o = ps;
				c_o = pc;
				prod_accum_o = {ps[0], prod_accum_i};
			end
		end
	endgenerate
endmodule

</pre>
</body>